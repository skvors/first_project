

Абстрактный класс может содержать объявление метода без его реализации. Такой метод называется абстрактным.

public abstract class ChessItem
{
    public int x, y; //координаты
    private int value; // «ценность» фигуры

    public int getValue() //обычный метод, возвращает значение value
    {
        return value;
    }

    public abstract void draw(); //абстрактный метод. Реализация отсутствует.

}

-------------------------------------------------

Абстрактный метод помечается специальным ключевым словом abstract.
Если в классе есть хоть один абстрактный метод, класс тоже помечается ключевым словом abstract.
Создавать объекты абстрактного класса нельзя. Такой код просто не скомпилируется.


ChessItem item = new ChessItem();
item.draw(); 	                     //Этот код не скомпилируется


ChessItem item = new Queen();
item.draw(); 	                     //А так можно.


Если ты наследовал свой класс от абстрактного класса, то нужно переопределить
все унаследованные абстрактные методы - написать для них реализацию.
Иначе такой класс тоже придется объявить абстрактным. Если в классе есть хотя-бы один нереализованный метод,
объявленный прямо в нем или унаследованный от класса-родителя, то класс считается абстрактным.

Зачем нужны абстрактные классы? Разве нельзя вместо них использовать обычные?
А вместо абстрактных методов просто писать две скобочки в качестве тела метода - {} ?
- Можно. Но эти ограничения сродни модификатору private. Мы специально запрещали с помощью private прямой доступ к данным,
чтобы другие программисты и их классы пользовались только написанными нами public-методами.

-------------------------------------------------

/* Классы Cat и Dog от Pet
Унаследуй классы Cat и Dog от Pet.
Реализуй недостающие методы. Классы Cat и Dog не должны быть абстрактными.
*/

public class Solution
{
    public static void main(String[] args)
    {
    }

    public static abstract class Pet
    {
        public abstract String getName();
        public abstract Pet getChild();
    }

    public static class Cat extends Pet
    {
        String name;
        public String getName()
        {
            return this.name;
        }

        public Cat getChild()
        {
            return new Cat();
        }
    }

    public static class Dog extends Pet
    {
        String name;
        public String getName()
        {
            return this.name;
        }

        public Dog getChild()              //после наследования при переопределении метода можно менять тип возвращаемого значения
        {                                  //был Pet мы поменяли на Dog, а можно и не менять главное чтоб типы были совместимы
            return new Dog();
        }
    }
}

-------------------------------------------------



-------------------------------------------------



-------------------------------------------------



-------------------------------------------------



-------------------------------------------------



