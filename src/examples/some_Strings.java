package examples;


public class some_Strings
{
    /*
    В классе String существует масса полезных методов, которые можно применять к строкам (перед именем метода будем указывать тип того значения,
        которое он возвращает):

    int length() — возвращает длину строки (количество символов в ней);
    boolean isEmpty() — проверяет, пустая ли строка;
    String replace(a, b) — возвращает строку, где символ a (литерал или переменная типа char) заменён на символ b;
    String toLowerCase() — возвращает строку, где все символы исходной строки преобразованы к строчным;
    String toUpperCase() — возвращает строку, где все символы исходной строки преобразованы к прописным;
    boolean equals(s) — возвращает истинну, если строка к которой применён метод,
        совпадает со строкой s указанной в аргументе метода (с помощью оператора == строки сравнивать нельзя, как и любые другие объекты);
    int indexOf(ch) — возвращает индекс символа ch в строке (индекс это порядковый номер символа,
        но нумероваться символы начинают с нуля). Если символ совсем не будет найден, то возвратит -1.
        Если символ встречается в строке нескольо раз, то вовзвратит индекс его первого вхождения.
    int lastIndexOf(ch) — аналогичен предыдущему методу, но возвращает индекс последнего вхождения,
        если смивол встретился в строке несколько раз.
    int indexOf(ch,n) — возвращает индекс символа ch в строке, но начинает проверку с индекса n (индекс это порядковый номер символа,
        но нумероваться символы начинают с нуля).
    char charAt(n) — возвращает код символа, находящегося в строке под индексом n (индекс это порядковый номер символа,
        но нумероваться символы начинают с нуля).

    getBytes() в Java имеет две формы:
        getBytes(String charsetName): кодирует данную строку в последовательность байтов, используя charsetName (кодировку), сохраняет результат в новый массив байтов.
        getBytes(): кодирует данную строку в последовательность байтов по умолчанию с помощью платформы charset, сохраняет результат в новый массив байтов.

    void getChars(int start, int end, char[] buffer, int index)  -   Метод для извлечения нескольких символов из строки.
        Вам надо указать индекс начала подстроки (start), индекс символа, следующего за концом извлекаемой подстроки (end).
        Массив, который принимает выделенные символы находится в параметре buffer.
        Индекс в массиве, начиная с которого будет записываться подстрока, передаётся в параметре index.
        Следите, чтобы массив был достаточного размера, чтобы в нём поместились все символы указанной подстроки.


        replaceAll("[^0-9]", "") - возвращает строку, в которой все кроме цифр заменено на пустоту
     */

    public static void out_str()
    {
        /* Экранирование символов
        Про экранирование символов в Java читайте в дополнительном материале к лекции.
        Вывести на экран следующий текст - две строки:

        It's Windows path: "C:\Program Files\Java\jdk1.7.0\bin"
        It's Java string: \"C:\\Program Files\\Java\\jdk1.7.0\\bin\"
        */
        //это называется экранирование символов
        String x = "\\";         // символ одной палки
        String y = "\"";         // символ одной кавычки
        System.out.println("It's Windows path: " + y + "C:" + x + "Program Files" + x + "Java" + x + "jdk1.7.0" + x + "bin" + y);
        System.out.println("It's Java string: " + x + y + "C:" + x + x + "Program Files" + x + x + "Java" + x + x + "jdk1.7.0" + x + x + "bin" + x + y);
    }

    public static void UpperCase_str()
    {
        String name = "Kitty";
        String up_name = name.toUpperCase();           //превращение символов в заглавные
        System.out.println(name);
        System.out.println(up_name);
    }

    public static void LowerCase_str()
    {
        String name = "KITty";
        String low_name = name.toLowerCase();           //превращение символов в прописные
        System.out.println(name);
        System.out.println(low_name);
    }

    public static void equals_str()
    {
        /* Единственный момент, который хотелось бы упомянуть – сравнение с литералами.
        Я часто вижу конструкции типа str.equals(«abc»). И тут есть небольшие грабли –
        перед этим сравнением правильно бы было сравнить str с null, чтобы не получить NullPointerException.
        Т.е. правильной будет конструкция str != null && str.equals(«abc»).
        Между тем – ее можно упростить. Достаточно написать всего лишь «abc».equals(str).
        Проверка на null в этом случае не нужна.
        */
        String str = "abc";
        System.out.println("abc".equals(str));
    }

    /* Сравнить имена
    Проверить два имени, и если имена одинаковые вывести сообщение «Имена идентичны».
    Если имена разные, но их длины равны – вывести сообщение – «Длины имен равны».     */

    public static void equal_example(String name1, String name2)
    {
        if (name1.equals(name2))            //сравнение строк name1 и name2 (здесь сравниваются не ссылки а сами объекты)
            System.out.print("Имена идентичны");
        else if (name1.length() == name2.length())
            System.out.print("Длины имен равны");
    }

    //когда мы складываем две переменных: String и «не String».
    //При этом «не String» переменная преобразовывается к типу String.


    public static void main(String[] args)
    {
        UpperCase_str();
        //equals_str();
        LowerCase_str();
    }




}
